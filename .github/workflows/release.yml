# =============================================================================
# Release Workflow — Build release artifacts, publish GitHub Release,
# and push extension image for CNPG Image Volume Extensions to GHCR.
#
# Triggered when a version tag (v*) is pushed.
# =============================================================================
name: Release

on:
  push:
    tags: ["v*"]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false  # never cancel a release in progress

env:
  CARGO_TERM_COLOR: always
  PG_VERSION: "18"
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository_owner }}/pg_stream-ext

permissions:
  contents: write   # create GitHub Releases
  packages: write   # push to GHCR

jobs:
  # ── Build release artifacts for each platform ───────────────────────────
  build-release:
    name: Build (${{ matrix.artifact_suffix }})
    runs-on: ${{ matrix.os }}
    timeout-minutes: 30
    continue-on-error: ${{ matrix.os == 'windows-2022' }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            artifact_suffix: linux-amd64
            archive_ext: tar.gz
          - os: ubuntu-24.04-arm
            artifact_suffix: linux-arm64
            archive_ext: tar.gz
          - os: macos-14
            artifact_suffix: macos-arm64
            archive_ext: tar.gz
          - os: windows-2022
            artifact_suffix: windows-amd64
            archive_ext: zip
    steps:
      - uses: actions/checkout@v4

      - name: Setup pgrx environment
        uses: ./.github/actions/setup-pgrx

      - name: Extract version from tag
        id: version
        shell: bash
        run: |
          VERSION="${GITHUB_REF_NAME#v}"
          echo "version=${VERSION}" >> "$GITHUB_OUTPUT"
          echo "Release version: ${VERSION}"

      - name: Build extension package
        shell: bash
        run: |
          # Use pgrx-managed pg_config to avoid picking up Strawberry Perl's PG11
          # pg_config on Windows (which appears first on PATH).
          # 'cargo pgrx info path pg18' returns the installation prefix dir;
          # the pg_config binary lives under bin/ inside that directory.
          PG_CONFIG_PATH="$(cargo pgrx info path pg18)/bin/pg_config"
          cargo pgrx package --pg-config "${PG_CONFIG_PATH}"

      - name: Create archive (tar.gz)
        if: matrix.archive_ext == 'tar.gz'
        shell: bash
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          ARCHIVE_NAME="pg_stream-${VERSION}-pg${PG_VERSION}-${{ matrix.artifact_suffix }}"
          mkdir -p "dist/${ARCHIVE_NAME}/lib" "dist/${ARCHIVE_NAME}/extension"

          # Find pgrx package output
          PKG_DIR=$(find target/release -maxdepth 1 -name 'pg_stream-pg*' -type d | head -1)
          if [[ -z "$PKG_DIR" ]]; then
            echo "ERROR: cannot find pgrx package output"
            exit 1
          fi

          # Copy shared library
          find "${PKG_DIR}" -name '*.so' -o -name '*.dylib' | while read f; do
            cp "$f" "dist/${ARCHIVE_NAME}/lib/"
          done

          # Copy extension control + SQL files
          find "${PKG_DIR}" -name '*.control' -o -name '*.sql' | while read f; do
            cp "$f" "dist/${ARCHIVE_NAME}/extension/"
          done

          # Copy docs
          cp README.md LICENSE INSTALL.md "dist/${ARCHIVE_NAME}/" 2>/dev/null || true

          cd dist
          tar czf "${ARCHIVE_NAME}.tar.gz" "${ARCHIVE_NAME}"
          echo "Archive: ${ARCHIVE_NAME}.tar.gz ($(du -h "${ARCHIVE_NAME}.tar.gz" | cut -f1))"

      - name: Create archive (zip)
        if: matrix.archive_ext == 'zip'
        shell: pwsh
        run: |
          $version = "${{ steps.version.outputs.version }}"
          $archiveName = "pg_stream-${version}-pg${{ env.PG_VERSION }}-${{ matrix.artifact_suffix }}"
          New-Item -ItemType Directory -Path "dist\${archiveName}\lib" -Force
          New-Item -ItemType Directory -Path "dist\${archiveName}\extension" -Force

          $pkgDir = Get-ChildItem -Path "target\release" -Directory -Filter "pg_stream-pg*" | Select-Object -First 1
          if (-not $pkgDir) {
            Write-Error "Cannot find pgrx package output"
            exit 1
          }

          # Copy DLL
          Get-ChildItem -Path $pkgDir.FullName -Recurse -Filter "*.dll" | ForEach-Object {
            Copy-Item $_.FullName "dist\${archiveName}\lib\"
          }

          # Copy control + SQL
          Get-ChildItem -Path $pkgDir.FullName -Recurse -Include "*.control","*.sql" | ForEach-Object {
            Copy-Item $_.FullName "dist\${archiveName}\extension\"
          }

          # Copy docs
          Copy-Item README.md, LICENSE, INSTALL.md "dist\${archiveName}\" -ErrorAction SilentlyContinue

          Compress-Archive -Path "dist\${archiveName}" -DestinationPath "dist\${archiveName}.zip"
          Write-Host "Archive: ${archiveName}.zip"

      - name: Upload release artifact
        uses: actions/upload-artifact@v4
        with:
          name: release-${{ matrix.artifact_suffix }}
          path: dist/*.${{ matrix.archive_ext }}
          retention-days: 30
          if-no-files-found: error

  # ── Smoke-test the Linux release artifact ───────────────────────────────
  test-release:
    name: Test release artifact
    needs: build-release
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - uses: actions/checkout@v4

      - name: Download Linux artifact
        uses: actions/download-artifact@v4
        with:
          name: release-linux-amd64
          path: dist/

      - name: Extract artifact
        run: |
          cd dist
          tar xzf *.tar.gz
          # Rename to fixed path so Dockerfile.ext can reference it
          mv pg_stream-*-linux-amd64 artifact
          ls -la artifact/lib/ artifact/extension/

      - name: Build extension image
        run: |
          docker build \
            --build-arg REPO_URL=${{ github.server_url }}/${{ github.repository }} \
            --build-arg VERSION=${{ needs.build-release.outputs.version || 'dev' }} \
            -t pg_stream-ext:test \
            -f cnpg/Dockerfile.ext \
            dist/

      - name: Verify extension image layout
        run: |
          # The extension image is scratch-based (no shell, no PostgreSQL).
          # Verify the file layout matches the CNPG Image Volume spec:
          #   /lib/pg_stream.so
          #   /share/extension/pg_stream.control
          #   /share/extension/pg_stream--<ver>.sql
          ID=$(docker create pg_stream-ext:test)
          mkdir -p /tmp/ext-verify
          docker cp "$ID:/lib/" /tmp/ext-verify/lib/
          docker cp "$ID:/share/" /tmp/ext-verify/share/
          docker rm "$ID"

          echo "=== Extension image contents ==="
          find /tmp/ext-verify -type f
          echo "==============================="

          # Verify required files exist
          test -f /tmp/ext-verify/lib/pg_stream.so
          test -f /tmp/ext-verify/share/extension/pg_stream.control
          ls /tmp/ext-verify/share/extension/pg_stream--*.sql

          # Verify image size is reasonable (< 50 MB)
          SIZE=$(docker image inspect pg_stream-ext:test --format='{{.Size}}')
          echo "Image size: ${SIZE} bytes"
          if [[ "$SIZE" -gt 52428800 ]]; then
            echo "WARNING: Extension image is larger than expected (> 50 MB)"
          fi

          echo "Extension image layout verified!"

      - name: SQL smoke test (composite image)
        run: |
          # Build a temporary composite image to verify the extension
          # actually works with PostgreSQL. This image is NOT shipped.
          cat > /tmp/Dockerfile.smoke <<'DOCKERFILE'
          FROM pg_stream-ext:test AS ext
          FROM postgres:18.1
          COPY --from=ext /lib/ /usr/lib/postgresql/18/lib/
          COPY --from=ext /share/extension/ /usr/share/postgresql/18/extension/
          DOCKERFILE

          docker build -t pg_stream_smoketest -f /tmp/Dockerfile.smoke .

          docker run -d --name smoketest \
            -e POSTGRES_PASSWORD=test \
            -e POSTGRES_HOST_AUTH_METHOD=trust \
            -p 5432:5432 \
            pg_stream_smoketest \
            postgres -c "shared_preload_libraries=pg_stream"

          echo "Waiting for PostgreSQL..."
          for i in $(seq 1 30); do
            if docker exec smoketest pg_isready -U postgres 2>/dev/null; then
              break
            fi
            sleep 1
          done

          if ! docker exec smoketest pg_isready -U postgres; then
            echo "ERROR: PostgreSQL did not become ready"
            docker logs smoketest
            exit 1
          fi

          docker exec smoketest psql -U postgres -c "CREATE EXTENSION pg_stream;"
          docker exec smoketest psql -U postgres -c \
            "SELECT extname, extversion FROM pg_extension WHERE extname = 'pg_stream';"
          docker exec smoketest psql -U postgres -c "SHOW pg_stream.enabled;"
          docker exec smoketest psql -U postgres -c "SELECT * FROM pgstream.pgs_status();"

          echo "Release smoke test passed!"

      - name: Cleanup
        if: always()
        run: docker rm -f smoketest 2>/dev/null || true

  # ── Publish GitHub Release ──────────────────────────────────────────────
  publish-release:
    name: Publish GitHub Release
    needs: [build-release, test-release]
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - uses: actions/checkout@v4

      - name: Download all release artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts/
          pattern: release-*

      - name: Collect release files
        run: |
          mkdir -p release-files
          find artifacts/ -type f \( -name '*.tar.gz' -o -name '*.zip' \) \
            -exec cp {} release-files/ \;
          echo "Release files:"
          ls -lh release-files/

      - name: Generate checksums
        run: |
          cd release-files
          sha256sum * > SHA256SUMS.txt
          cat SHA256SUMS.txt

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          generate_release_notes: true
          files: |
            release-files/*
          draft: false
          prerelease: ${{ contains(github.ref_name, '-rc') || contains(github.ref_name, '-beta') || contains(github.ref_name, '-alpha') }}

  # ── Publish extension image to GHCR (per-arch, parallel) ──────────────
  # Builds each arch extension image (scratch-based) from the pre-built
  # .so artifact — no Rust recompilation. For CNPG Image Volume Extensions.
  # amd64 and arm64 run in parallel, then a manifest is merged.
  publish-docker-arch:
    name: Docker image (${{ matrix.arch }})
    needs: [build-release, test-release]
    runs-on: ${{ matrix.runner }}
    timeout-minutes: 10
    strategy:
      fail-fast: false
      matrix:
        include:
          - arch: linux/amd64
            runner: ubuntu-latest
            artifact_suffix: linux-amd64
            platform_tag: amd64
          - arch: linux/arm64
            runner: ubuntu-24.04-arm
            artifact_suffix: linux-arm64
            platform_tag: arm64
    steps:
      - uses: actions/checkout@v4

      - name: Download ${{ matrix.artifact_suffix }} artifact
        uses: actions/download-artifact@v4
        with:
          name: release-${{ matrix.artifact_suffix }}
          path: dist/

      - name: Extract artifact
        run: |
          cd dist && tar xzf *.tar.gz
          # Rename extracted dir to a fixed path for Dockerfile.ext
          mv pg_stream-*-${{ matrix.artifact_suffix }} artifact
          ls -la artifact/lib/ artifact/extension/

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Extract version from tag
        id: version
        run: echo "version=${GITHUB_REF_NAME#v}" >> "$GITHUB_OUTPUT"

      - name: Build and push ${{ matrix.arch }} image
        uses: docker/build-push-action@v5
        with:
          context: dist/
          file: cnpg/Dockerfile.ext
          push: true
          platforms: ${{ matrix.arch }}
          build-args: |
            REPO_URL=${{ github.server_url }}/${{ github.repository }}
            VERSION=${{ steps.version.outputs.version }}
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.version.outputs.version }}-${{ matrix.platform_tag }}
          labels: |
            org.opencontainers.image.title=pg_stream-ext
            org.opencontainers.image.description=pg_stream extension for CloudNativePG Image Volume Extensions
            org.opencontainers.image.licenses=Apache-2.0
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # ── Merge per-arch extension images into a single multi-arch manifest ──
  publish-docker:
    name: Publish Docker manifest
    needs: publish-docker-arch
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Extract version from tag
        id: version
        run: echo "version=${GITHUB_REF_NAME#v}" >> "$GITHUB_OUTPUT"

      - name: Create and push multi-arch manifest
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"

          # Create versioned manifest (e.g. 0.1.0)
          docker buildx imagetools create \
            --tag "${IMAGE}:${VERSION}" \
            "${IMAGE}:${VERSION}-amd64" \
            "${IMAGE}:${VERSION}-arm64"

          # Also tag major.minor (e.g. 0.1)
          MINOR="$(echo "${VERSION}" | cut -d. -f1-2)"
          docker buildx imagetools create \
            --tag "${IMAGE}:${MINOR}" \
            "${IMAGE}:${VERSION}-amd64" \
            "${IMAGE}:${VERSION}-arm64"

          # Tag latest for non-prerelease
          if [[ "${GITHUB_REF_NAME}" != *"-"* ]]; then
            docker buildx imagetools create \
              --tag "${IMAGE}:latest" \
              "${IMAGE}:${VERSION}-amd64" \
              "${IMAGE}:${VERSION}-arm64"
          fi

          echo "Multi-arch manifest created for ${IMAGE}:${VERSION}"
          docker buildx imagetools inspect "${IMAGE}:${VERSION}"
